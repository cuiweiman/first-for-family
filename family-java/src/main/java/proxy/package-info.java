/**
 * 动态代理: 在不改动原有方法的基础上，进行功能增强。场景如 声明式事务、AOP 切面 等。
 * 一般有 JDK 动态代理和 第三方 CGLib 动态代理两种实现。
 * 在 Spring 中，当 Bean 实现接口时，Spring 就会用 JDK 的动态代理；
 * Bean 没有实现接口时，Spring 使用 CGlib 实现动态代理。
 * <p>
 * JDK 动态代理{@link proxy.jdkproxy.JdkProxyTest}
 * <p>
 * CGLib 动态代理 {@link proxy.cglibproxy.CglibProxy}
 * CGLIB基于底层的字节码操作技术，利用 ASM 库 动态生成 新的 Java 类（通常是目标类的子类）。
 * 这些新生成的类继承自目标类，并在方法调用时插入代理逻辑。
 * 这种机制使得CGLIB能够在不修改原有类代码的情况下，为其提供增强功能.
 * <p>
 * JDK 动态代理 对比 CGLib 动态代理：
 * 1. JDK 动态代理基于接口，目标对象需要实现一个接口。代理对象是接口的实现类，并通过反射调用接口方法。
 * CGLIB 代理 基于子类，能够代理 未实现接口的类。代理对象是 目标类的子类，通过 继承和方法覆写 实现拦截。
 * <p>
 * 2. 仅需代理接口方法且创建代理对象频率较低的场景，JDK动态代理通常拥有更好的性能，因为它不需要生成额外的类文件，也不涉及字节码操作。
 * 需要代理 非接口类 或 频繁创建/销毁代理对象 的情况下，CGLIB 由于其高效的字节码生成和缓存策略，可能会表现出更优的性能。
 * <p>
 * 3. JDK动态代理依赖接口，无法应用于 未声明接口的类。同时对于final类和方法，以及带有final修饰符的成员变量，JDK动态代理无能为力。
 * CGLIB 理论上可以代理任何 非final类，但对于final类、final方法以及构造函数，CGLIB同样无法进行代理。
 */
package proxy;
/**
 * 分布式锁:
 * 原理：多线程创建同一个znode节点时，只有一个线程能够执行成功。
 * <p>
 * 方案一：
 * 基于『临时节点』实现分布式锁，会产生『羊群效应』，
 * 羊群效应: 若所有锁的请求者都 watch 锁持有者，当锁持有者znode 被删掉后，ZK服务器需要通知到所有的锁请求者，
 * 但只有一个锁请求者能得到锁，造成服务资源和网络带宽资源的占用。
 * <a href="https://zhuanlan.zhihu.com/p/126345341">Zookeeper分布式锁介绍</a>
 * <p>
 * 方案二：
 * 基于『临时顺序节点』znode 表示获取锁的请求，创建出最小的后缀数字 znode 节点的线程可以成功获取到锁。
 * 第二个用户 监控第一个成功创建 后缀数字最小znode 的节点，第三个用户监控第二个用户的节点。
 * 即每个锁请求者 watch 前一个锁请求者的 znode，锁被释放时只有一个锁请求者会被通知到，实现锁分配的先到先得原则。
 * 从而避免羊群效应(若所有客户争强锁时都监控第一个获取到锁的用户znode，会导致ZK服务端通过很多客户端造成性能下降)。
 * <p>
 * 由于网络异常或者其它原因，导致占有锁的客户端失联，Zookeeper 也可以根据临时节点的特性即使删除节点即释放锁，
 * 且该节点的监听客户端也会收到Zookeeper服务端的通知。
 * <p>
 * 临时节点特性：
 * 1. Session过期时，ZK会删除该Session创建的所有临时节点
 * a. 清理其父节点下的当前节点信息；b. 删除当前临时节点信息；c. 触发当前节点的所有监听事件。
 * <p>
 * 1. 在 /distributes_lock 下创建 临时顺序性节点
 * 2. 获取 /distributes_lock 下所有子节点，并按照后缀数字序号由小到大排序
 * 3. 判断当前线程创建的节点序号是否是最小的？是—>成功获得锁；否—>阻塞线程，监听比自己后缀数字小1的节点的删除事件，删除后进入步骤2.
 * 4. 获得锁的线程执行业务结束后，删除锁节点表示释放。并通知监听本节点的客户端线程执行获取锁的过程。
 * <p>
 * 一般我们认为，ZooKeeper 的分布式锁是基于『临时顺序节点，然后通过监听机制来实现的』。即方案2
 * <p>
 */
package com.first.family.demo.distrubutedlock;
- [MQTT教程](https://www.emqx.com/zh/mqtt-guide)
- [MQTT-Java客户端](https://www.emqx.com/zh/blog/how-to-use-mqtt-in-java)

[TOC]

# MQTT协议简介

## docker 部署

```bash
docker pull emqx/emqx:5.1.0

docker run -d --name my-emqx -p 1883:1883 -p 8083:8083 -p 8084:8084 -p 8883:8883 -p 18083:18083 emqx/emqx:5.1.0
```

## 概览

[MQTT](https://mqtt.org/)（Message Queuing Telemetry Transport）是一种轻量级、基于发布-订阅模式的消息传输协议。

适用于资源受限的设备和低带宽、高延迟或不稳定的网络环境。

它在物联网应用中广受欢迎，能够实现传感器、执行器和其它设备之间的高效通信。

## MQTT协议与Http协议比较

- MQTT 的最小报文仅为 2 个字节，比 HTTP 占用更少的网络开销。
- MQTT 与 HTTP 都能使用 TCP 连接，并实现稳定、可靠的网络连接。
- MQTT 基于发布订阅模型，支持双工通信，HTTP 基于请求响应。
- MQTT 可实时推送消息，但 HTTP 需要通过轮询获取数据更新。
- MQTT 是有状态的，但是 HTTP 是无状态的。
- MQTT 可从连接异常断开中恢复，HTTP 无法实现此目标。

## MQTT是物联网的最佳协议

大规模的物联网需求下，海量的设备接入和设备管理对网络带宽、通信协议以及平台服务架构都带来了巨大的挑战。

对于物联网协议来说，必须针对性地解决物联网设备通信的几个关键问题：

- 网络环境复杂而不可靠
- 内存和闪存容量小
- 处理器能力有限。

MQTT 协议正是为了应对以上问题而创建：

- 轻量高效，节省带宽
- [可靠的消息传递](https://www.emqx.com/zh/blog/introduction-to-mqtt-qos)
    - **QoS 0：消息最多传递一次。只需要发送一次**  
      如果当时客户端不可用，则会丢失该消息。发布者发送一条消息之后，就不再关心它有没有发送到对方，也不设置任何重发机制。
    - **QoS 1：消息传递至少 1 次。发送至少一次，直到收到一次响应**  
      加入了应答与重传机制，发送方只有在收到接收方的 PUBACK 报文以后，才能认为消息投递成功，在此之前，发送方需要存储该
      PUBLISH 报文以便下次重传。  
      能保证消息至少能到达一次，但可能消息重复。
    - **QoS 2：消息仅传送一次。性能低，需要两次发送和响应**  
      设计了重发和重复消息发现机制，保证消息到达对方并且严格只到达一次。
- 海量连接支持  
  可轻松具备高并发、高吞吐、高可扩展能力。EMQX 5.0 通过一个 23 节点的集群达成了 1 亿 MQTT 连接+每秒 100 万消息吞吐。
- 安全的双向通信  
  支持通过 TLS/SSL 确保安全的双向通信，同时 MQTT 协议中提供的客户端 ID、用户名和密码允许我们实现应用层的身份验证和授权。
- 状态感知
    - 提供了[心跳保活（Keep Alive）机制](https://www.emqx.com/zh/blog/mqtt-keep-alive)
    - 设计了[遗愿（Last Will）消息](https://www.emqx.com/zh/blog/use-of-mqtt-will-message), 客户端异常下线的情况下，服务端会发布一条遗愿消息到指定的
      MQTT 主题。

## 检活和遗嘱

MQTT 协议是承载于 TCP 协议之上的，而 TCP 协议以连接为导向，在连接双方之间，提供稳定、有序的字节流功能。

TCP 可能出现半连接问题。所谓半连接，是指某一方的连接已经断开或者没有建立，而另外一方的连接却依然维持着。半连接的一方可能会持续不断地向对端发送数据，而这些数据永远到达不了对端。

为了避免半连接导致的通信黑洞，MQTT 协议提供了 Keep Alive 机制，使客户端和 MQTT 服务器可以判定当前是否存在半连接问题，从而关闭对应连接。

### 启用 Keep Alive

客户端在创建和 MQTT Broker 的连接时，只要将连接请求协议包内的 Keep Alive 可变头部字段设置为非 0 值，就可以在通信双方间启用
Keep Alive 机制。

Keep Alive 为 0~65535 的一个整数，代表客户端发送两次 MQTT 协议包之间的最大间隔时间。

Broker 在收到客户端的连接请求后，会检查可变头部中的 Keep Alive 字段的值，如果有值，则 Broker 将会启用 Keep Alive 机制。

### Will Message 遗嘱

遗嘱消息可以看作是一个简化版的 PUBLISH 消息，他也包含 Topic, Payload, QoS 等字段。

遗嘱消息会在设备与服务端连接时，通过 CONNECT 报文指定，然后在设备意外断线时由服务端将该遗嘱消息发布到连接时指定的遗嘱主题（Will
Topic）上。

为可能出现 意外断线 的设备提供的将 遗嘱 优雅地发送给第三方的能力。

- 因网络故障或网络波动，设备在保持连接周期内未能通讯，连接被服务端关闭。
- 设备意外掉电。
- 设备尝试进行不被允许的操作而被服务端关闭连接，例如订阅自身权限以外的主题等。

## MQTT连接

客户端与服务器建立网络连接后，需要先发送一个 CONNECT 数据包给服务器。服务器收到 CONNECT 包后会回复一个 CONNACK 给客户端，客户端收到
CONNACK 包后表示 MQTT 连接建立成功。如果客户端在超时时间内未收到服务器的 CONNACK 数据包，就会主动关闭连接。

大多数场景下，MQTT 通过 TCP/IP 协议进行网络传输，但是 MQTT 同时也支持通过 WebSocket 或者 UDP 进行网络传输。

- TCP/IP 应用广泛，是一种面向连接的、可靠的、基于字节流的传输层通信协议。它通过 ACK
  确认和重传机制，能够保证发送的所有字节在接收时是完全一样的，并且字节顺序也是正确的。
- WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API
  中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。

### 连接参数

- 连接地址: 服务器IP、域名、端口、连接协议。
    - mqtt 基于 tcp ，端口通常是 1883
    - mqtts 基于 TLS/SSL 的安全连接，端口通常是 8883
    - ws 基于 普通 WebSocket 的连接，端口通常是 8083
    - wss 基于 普通 WebSocket 的安全连接，端口通常是 8084
- 客户端ID(ClientID): 每个客户端都必须要有唯一的 Client ID，若重复会踢掉已连接的客户端。
- 用户名和密码: 使用安全连接时, 需要配置。匿名认证则不需要。
- 连接超时(ConnectTimeout): 连接超时时长，收到服务器连接确认前的等待时间，等待时间内未收到连接确认则为连接失败。
- 保活周期(KeepAlive): 是一个以秒为单位的时间间隔。
    - 客户端在无报文发送时，将按 Keep Alive
      设定的值定时向服务端发送心跳报文，确保连接不被服务端断开。
    - 如果服务器没有在 Keep Alive 的 1.5 倍时间内收到来自客户端的任何包，则会认为和客户端之间的连接出现了问题，便会断开和客户端的连接。
- 清除会话(Clean Session):
    - 前提是客户端使用固定的 Client ID 再次连接
    - 避免了客户端掉线重连后消息的丢失，不保存 QoS 0 消息。
    - false: 创建一个持久会话，在客户端断开连接时，会话仍然保持并保存离线消息，直到会话超时注销。
    - true: 创建一个新的临时会话，在客户端断开时，会话自动销毁。
- 遗嘱消息(Last Will):
    - 为可能出现意外断线的设备提供的将遗嘱优雅地发送给其他客户端的能力。
    - 设置了遗嘱消息消息的 MQTT 客户端异常下线时，MQTT 服务器会发布该客户端设置的遗嘱消息。

> 协议版本: MQTT 协议版本有 MQTT v3.1、MQTT v3.1.1 及 MQTT v5.0。目前，MQTT 5.0 已成为绝大多数物联网企业的首选协议。

**MQTT5.0 新增的连接参数**

- Clean Start: 指定连接时是创建一个全新的会话还是尝试复用一个已存在的会话。
    - true 表示必须丢弃任何已存在的会话，并创建一个全新的会话。
    - false 表示必须使用与 Client ID 关联的会话来恢复与客户端的通信（除非会话不存在）。
- Session Expiry Interval: 用于指定网络连接断开后会话的过期时间。
    - 0或未设置 表示断开连接时会话即到期
    - 大于 0 的数值，表示会话在网络连接关闭后会保持多少秒
    - 0xFFFFFFFF 表示会话永远不会过期
- 连接属性(Connect Properties): [](https://www.emqx.com/zh/blog/mqtt5-connect-properties)

### Topic

> Topic 的通配符 支持 + 和 #。通配符只能订阅，不能用于发布。
> - \+ 表示单层通配符, a/+ 可以匹配到 a/x
> - \# 是多层通配符, a/# 可以匹配到 a/x、a/x/y/z

- 建议主题层级为 7 个以内，较短的主题名称和较少的主题层级，可以减少内存消耗。
- 通配符方式订阅，会消耗更多服务器资源。
- 一个主题可以同时被共享订阅和普通订阅，但不建议同时使用。
- 不建议使用 # 订阅所有主题，以及使用 / 开头或结尾的主题，如 /chat 或 chat/。
- 不建议在主题里添加空格及非 ASCII 特殊字符；
- 同一主题层级内建议使用下划线 _ 或横杆 - 连接单词（或者使用驼峰命名）
- 当使用通配符时，将唯一值的主题层（例如设备号）越靠近第一层越好。例如，device/00000001/command/# 比
  device/command/00000001/# 更好。

### 保留消息

发布订阅模式虽然能让消息的发布者与订阅者充分解耦，但也存在一个缺点，即订阅者无法主动向发布者请求消息。订阅者何时收到消息完全依赖于发布者何时发布消息，这在某些场景中就产生了不便。例如：

- 智能家居设备的状态只有在变更时才会上报，但是控制端需要在上线后就能获取到设备的状态；
- 传感器上报数据的间隔太长，但是订阅者需要在订阅后立即获取到最新的数据；
- 传感器的版本号、序列号等不会经常变更的属性，可在上线后发布一条保留消息告知后续的所有订阅者。

**使用 MQTT 保留消息**

> 只需在消息发布时将 Retained 状态设置为 true 即可

- 客户端订阅了有保留消息的主题后，即会收到该主题的保留消息，可通过消息中的保留标志位判断是否是保留消息。
- 服务器只会为每个主题保存最新一条保留消息，保留消息的保存时间与服务器的设置有关。若服务器设置保留消息存储在内存，则 MQTT
  服务器重启后消息即会丢失；若存储在磁盘，则服务器重启后保留消息仍然存在。

**删除 MQTT 保留消息**

- 客户端往某个主题发送一个 Payload 为空的保留消息，服务端就会删除这个主题下的保留消息；
- 在 MQTT 服务器上删除，比如 EMQX MQTT 服务器提供了在 Dashboard 上删除保留消息的功能；
- MQTT 5.0 新增了消息过期间隔属性，发布时可使用该属性设置消息的过期时间，不管消息是否为保留消息，都将会在过期时间后自动被删除。

## 规则引擎配置

```sql
SELECT payload           as payload,
       split(topic, '/') as topics,
       topics[3]         as deviceId
FROM "gc/media/+"
```

```sql
SELECT concat('ReqId-', now_timestamp('nanosecond')) as reqId,
       'thing.property.post'                         as method,
       '1.0'                                         as version,
       now_timestamp('millisecond') as timestamp,
  payload.payload as properties,
  payload.deviceId as deviceId
FROM "gc/media/republish/#"
```


